// Copyright (c) 2020 Private Internet Access, Inc.
//
// This file is part of the Private Internet Access Desktop Client.
//
// The Private Internet Access Desktop Client is free software: you can
// redistribute it and/or modify it under the terms of the GNU General Public
// License as published by the Free Software Foundation, either version 3 of
// the License, or (at your option) any later version.
//
// The Private Internet Access Desktop Client is distributed in the hope that
// it will be useful, but WITHOUT ANY WARRANTY; without even the implied
// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with the Private Internet Access Desktop Client.  If not, see
// <https://www.gnu.org/licenses/>.

#include "common.h"
#line SOURCE_FILE("win/win_tray.cpp")

#include "win_tray.h"
#include "win_resources.h"
#include "win/win_util.h"
#include <QUuid>
#include <QRect>
#include <QPoint>
#include <QGuiApplication>
#include <QTimer>
#include <QRectF>
#include <QTimer>
#include <windowsx.h>   // GET_X_LPARAM() and GET_Y_LPARAM()
#include <string.h> // For wcsncpy_s(), used to fill NOTIFYICONDATAW buffers
#include <VersionHelpers.h>

#include <windows.h>
#pragma comment(lib, "User32.lib")

namespace
{
    template <size_t size>
    void fillWCharArray(wchar_t (&strDest)[size], const QString &value)
    {
        if(value.length() >= size)
        {
            qWarning() << "String exceeds buffer length" << size
                << "- truncating:" << value;
        }
        ::wcsncpy_s(strDest, qstringWBuf(value), _TRUNCATE);
    }

    QRect scaleRect(const QRect &value, double scale)
    {
        return QRectF{value.x() * scale, value.y() * scale,
                      value.width() * scale, value.height() * scale}.toRect();
    }
}

QUuid ShellTrayIcon::_iconId{};
QUuid ShellTrayIcon::_iconGuidNamespace{0xbbb16313, 0xfec1, 0x4acf, 0xa2, 0x96,
                                        0xd3, 0x7e, 0x82, 0xbb, 0x38, 0x7d};
NOTIFYICONDATAW ShellTrayIcon::_defaultIconData{};

void ShellTrayIcon::initIconGuid()
{
    if(!_iconId.isNull())
        return; //Already initialized

    QString appPath = QCoreApplication::applicationFilePath();
    _iconId = QUuid::createUuidV5(_iconGuidNamespace, appPath);

    _defaultIconData.cbSize = sizeof(_defaultIconData);
    _defaultIconData.uFlags = NIF_SHOWTIP|NIF_GUID;
    _defaultIconData.guidItem = _iconId;
}

ShellTrayIcon::ShellTrayIcon(HICON initialIcon)
    : _recentKeySelect{false},
      _explorerCrashReceiver{this}
{
    initIconGuid();
    _lastUsedIcon = initialIcon;
    createIcon(initialIcon);
}

ShellTrayIcon::~ShellTrayIcon()
{
    if(!deleteIcon())
        qWarning() << "Error result from deleting icon:" << ::GetLastError();
}

void ShellTrayIcon::redrawIcon()
{
    deleteIcon();
    createIcon(_lastUsedIcon);
}

bool ShellTrayIcon::deleteIcon()
{
    NOTIFYICONDATAW iconData{_defaultIconData};
    return ::Shell_NotifyIconW(NIM_DELETE, &iconData);
}

LRESULT ShellTrayIcon::handleIconMsg(WORD msg, int x, int y)
{
    // These messages need to work for keyboard-based interaction as well as
    // cursor-based interaction.
    // To test keyboard interaction, use Win+B to focus the notification area,
    // then use arrows to navigate, space to left-click, and the app menu key
    // to show the context menu.
    switch(msg)
    {
    default:
        return 0;
    case WM_CONTEXTMENU:
        // Show the context menu at (x, y).  This can be sent due to a cursor
        // interaction, in which case (x, y) is the click position, or it can be
        // sent from a keyboard interaction, in which case (x, y) is a default
        // position for the menu in the icon (seems to be the center on Windows
        // 10, doc actually says top-left).
        emit showMenu({x, y});
        return 0;
    case NIN_SELECT:
        // Show the dashboard.
        emit leftClicked();
        return 0;
    case NIN_KEYSELECT:
        // Windows generates this message twice when pressing the Enter key, but
        // once when pressing Spacebar.
        // Work around it by ignoring the event if it's generated twice in quick
        // succession.  This isn't perfect, but it's the best we can do with the
        // buggy events generated by Windows.
        if(_recentKeySelect)
            return 0;

        _recentKeySelect = true;
        QTimer::singleShot(100, this, [this](){_recentKeySelect=false;});

        // Show the dashboard.
        emit leftClicked();
        return 0;
    }
}

LRESULT ShellTrayIcon::proc(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uMsg)
    {
    case IconMsg:
        // Icon messages really do pack the XY position into wParam, despite the
        // macro names specifically calling out LPARAM.
        // LOWORD(lParam) is the message ID.
        // HIWORD(lParam) is the icon ID, which we don't care about.
        return handleIconMsg(LOWORD(lParam), GET_X_LPARAM(wParam), GET_Y_LPARAM(wParam));
    default:
        return MessageWnd::proc(uMsg, wParam, lParam);
    }
}

void ShellTrayIcon::createIcon(HICON trayIcon)
{
    // There could be an icon still hanging around if the client had crashed.
    // We have to delete it before we can recreate it.
    deleteIcon();   // Failure ignored

    NOTIFYICONDATAW iconData{_defaultIconData};
    iconData.uFlags |= NIF_MESSAGE|NIF_ICON;
    iconData.hWnd = getHwnd();
    iconData.uCallbackMessage = IconMsg;
    iconData.hIcon = trayIcon;

    if(!::Shell_NotifyIconW(NIM_ADD, &iconData))
    {
        qWarning() << "Failed to create icon";
        return;
    }
    iconData.uVersion = NOTIFYICON_VERSION_4;
    if(!::Shell_NotifyIconW(NIM_SETVERSION, &iconData)) {
        qWarning () << "Failed to create icon";
        return;
    }
}

QRect ShellTrayIcon::getIconBound() const
{
    NOTIFYICONIDENTIFIER iconId{};
    iconId.cbSize = sizeof(NOTIFYICONIDENTIFIER);
    iconId.guidItem = _iconId;
    RECT iconBound{};
    ::Shell_NotifyIconGetRect(&iconId, &iconBound);
    return {iconBound.left, iconBound.top, iconBound.right - iconBound.left,
            iconBound.bottom - iconBound.top};
}

void ShellTrayIcon::setIcon(HICON trayIcon)
{
    NOTIFYICONDATAW iconData{_defaultIconData};
    iconData.uFlags |= NIF_ICON;
    iconData.hIcon = trayIcon;
    _lastUsedIcon = trayIcon;

    if(!::Shell_NotifyIconW(NIM_MODIFY, &iconData))
        qWarning() << "Unable to update tray icon:" << SystemError{HERE};
}

void ShellTrayIcon::showNotification(HICON notificationIcon, const QString &title, const QString &message)
{
    NOTIFYICONDATAW iconData{_defaultIconData};
    iconData.uFlags |= NIF_INFO;
    // If szInfo is empty, Windows interprets this as deleting the notification,
    // even if a title is set.  Use a non-empty string to work around it.
    const QString &infoStr = message.isEmpty() ? QStringLiteral(" ") : message;
    fillWCharArray(iconData.szInfo, infoStr);
    fillWCharArray(iconData.szInfoTitle, title);
    iconData.dwInfoFlags = NIIF_USER|NIIF_LARGE_ICON|NIIF_NOSOUND;
    iconData.hBalloonIcon = notificationIcon;
    if(!::Shell_NotifyIconW(NIM_MODIFY, &iconData))
        qWarning() << "Unable to display notification:" << title << "/" << message;
}

void ShellTrayIcon::hideNotification()
{
    NOTIFYICONDATAW iconData{_defaultIconData};
    // Set NIF_INFO, but leave all the info-related members zeroed to delete the
    // notification.
    iconData.uFlags |= NIF_INFO;
    if(!::Shell_NotifyIconW(NIM_MODIFY, &iconData))
        qWarning() << "Unable to remove notification";
}

void ShellTrayIcon::setToolTip(const QString& toolTip)
{
    NOTIFYICONDATAW iconData{_defaultIconData};
    iconData.uFlags |= NIF_TIP;
    fillWCharArray(iconData.szTip, toolTip);
    if(!::Shell_NotifyIconW(NIM_MODIFY, &iconData))
        qWarning() << "Unable to set tray tooltip:" << toolTip;
}

WORD TrayIconLoader::iconForWinVer(WORD noOutlineId, WORD outlineId)
{
    if(useOutlineIcons())
        return outlineId;
    return noOutlineId;
}

bool TrayIconLoader::useOutlineIcons()
{
    // Windows 10 uses the same background color for the taskbar and overflow
    // area, and they use plain light icons for the OS icons, so the no-outline
    // icons are used.
    //
    // Windows 7 uses outlined icons for the OS icons.  It uses different colors
    // for the taskbar and overflow area, so the outline is needed for the icon
    // to be visible in both contexts.
    //
    // Windows 8 and 8.1 are more or less like 7.
    return !::IsWindows10OrGreater();
}

TrayIconLoader::TrayIconLoader(IconResource::Size size, const QString &initialIconSet)
    : _size{size},
#if BRAND_HAS_CLASSIC_TRAY
      _theme_classic{size,
                     IDI_CLASSIC_ALERT,
                     IDI_CLASSIC_CONNECTED,
                     IDI_CLASSIC_CONNECTING,
                     IDI_CLASSIC_CONNECTING,
                     IDI_CLASSIC_DOWN,
                     IDI_CLASSIC_SNOOZED
                     },
#endif
      _theme_light{size,
                   iconForWinVer(IDI_LIGHT_ALERT,         IDI_LIGHT_OUTLINE_ALERT),
                   iconForWinVer(IDI_LIGHT_CONNECTED,     IDI_LIGHT_OUTLINE_CONNECTED),
                   iconForWinVer(IDI_LIGHT_CONNECTING,    IDI_LIGHT_OUTLINE_CONNECTING),
                   iconForWinVer(IDI_LIGHT_DISCONNECTING, IDI_LIGHT_OUTLINE_DISCONNECTING),
                   iconForWinVer(IDI_LIGHT_DOWN,          IDI_LIGHT_OUTLINE_DOWN),
                   iconForWinVer(IDI_LIGHT_SNOOZED,       IDI_LIGHT_OUTLINE_SNOOZED),
                   },
      _theme_colored{size,
                     iconForWinVer(IDI_COLORED_ALERT,         IDI_COLORED_OUTLINE_ALERT),
                     iconForWinVer(IDI_COLORED_CONNECTED,     IDI_COLORED_OUTLINE_CONNECTED),
                     iconForWinVer(IDI_COLORED_CONNECTING,    IDI_COLORED_OUTLINE_CONNECTING),
                     iconForWinVer(IDI_COLORED_DISCONNECTING, IDI_COLORED_OUTLINE_DISCONNECTING),
                     iconForWinVer(IDI_COLORED_DOWN,          IDI_COLORED_OUTLINE_DOWN),
                     iconForWinVer(IDI_COLORED_SNOOZED,       IDI_COLORED_OUTLINE_SNOOZED),
                     }
{
    setIconSet(initialIconSet);
}

void TrayIconLoader::setIconSet(const QString &iconSet) {
    if(iconSet != _iconSet)
    {
        _iconSet = iconSet;
    }
}

const IconResource &TrayIconLoader::getStateIcon(NativeTray::IconState state) const
{
    if(_iconSet == QStringLiteral("colored"))
        return _theme_colored.getIconForState(state);
#if BRAND_HAS_CLASSIC_TRAY
    else if(_iconSet == QStringLiteral("classic"))
        return _theme_classic.getIconForState(state);
#endif
    // light (default for bogus theme)
    return _theme_light.getIconForState(state);
}

NativeTrayWin::NativeTrayWin(IconState initialIcon, const QString &initialIconSet)
    : _trayIcons{IconResource::Size::Small, initialIconSet},
      _notificationIcons{IconResource::Size::Large, initialIconSet},
      _icon{_trayIcons.getStateIcon(initialIcon).getHandle()}
{
    connect(&_icon, &ShellTrayIcon::leftClicked, this, &NativeTrayWin::onLeftClicked);
    connect(&_icon, &ShellTrayIcon::showMenu, this, &NativeTrayWin::onShowMenu);
}

void NativeTrayWin::setIconState(IconState icon, const QString &iconSet)
{
    _trayIcons.setIconSet(iconSet);
    _notificationIcons.setIconSet(iconSet);
    _icon.setIcon(_trayIcons.getStateIcon(icon).getHandle());
}

void NativeTrayWin::showNotification(IconState icon, const QString &title,
                                     const QString &subtitle)
{
    // Unlike other platforms, we don't include the product name as a default
    // subtitle on Windows.  The OS automatically reads it from the VERSIONINFO
    // resource and includes it.
    _icon.showNotification(_notificationIcons.getStateIcon(icon).getHandle(),
                           title, subtitle);
}

void NativeTrayWin::hideNotification()
{
    _icon.hideNotification();
}

void NativeTrayWin::setToolTip(const QString& toolTip)
{
    _icon.setToolTip(toolTip);
}

void NativeTrayWin::setMenuItems(const NativeMenuItem::List& items)
{
    _menu.setItems(items);
}

void NativeTrayWin::getIconBound(QRect &iconBound, qreal &screenScale)
{
    iconBound = _icon.getIconBound();

    RECT winIconBound{iconBound.left(), iconBound.top(), iconBound.right(),
                      iconBound.bottom()};
    HMONITOR iconMonitor = ::MonitorFromRect(&winIconBound,
                                             MONITOR_DEFAULTTONEAREST);
    screenScale = WinScaler::checkScaleLock(_monitorScale.getMonitorScale(iconMonitor));
}

void NativeTrayWin::onLeftClicked()
{
    QRect iconBound{};
    qreal screenScale{1.0};
    getIconBound(iconBound, screenScale);
    emit leftClicked(iconBound, screenScale);
}

void NativeTrayWin::onShowMenu(const QPoint &pos)
{
    // Hide any existing notifications so it doesn't cover up the menu.
    this->hideNotification();

    // Use the tray icon's message window as the foreground window.  Nothing
    // will actually appear on screen since it's a message-only window, and no
    // messages are sent to it, but TrackPopupMenu() still requires a window
    // from this thread.
    auto result = _menu.showMenu(_icon.getHwnd(), pos);
    if (!result.isNull()) {
        emit menuItemSelected(result);
    }
}

std::unique_ptr<NativeTray> createNativeTrayWin(NativeTrayIconState::IconState initialIcon, const QString &initialIconSet)
{
    return std::unique_ptr<NativeTray>{new NativeTrayWin(initialIcon, initialIconSet)};
}


TrayCreatedReceiver::TrayCreatedReceiver(ShellTrayIcon *tray) : MessageWnd{WindowType::Invisible}, _tray{tray}
{
    _trayCreatedCode = ::RegisterWindowMessageW(L"TaskbarCreated");
    if(!_trayCreatedCode)
    {
        qWarning() << "Unable to register tray created message - error"
            << ::GetLastError();
    }
}

LRESULT TrayCreatedReceiver::proc(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if(_trayCreatedCode && uMsg == _trayCreatedCode)
    {
        qDebug () << "Detected tray created message. Requesting shell tray re-draw";
        _tray->redrawIcon();
    }

    return MessageWnd::proc(uMsg, wParam, lParam);
}

IconTheme::IconTheme(IconResource::Size size, WORD alert_code, WORD connected_code, WORD connecting_code, WORD disconnecting_code, WORD disconnected_code, WORD snoozed_code) :
    _alert{alert_code, size},
    _connected{connected_code, size},
    _connecting{connecting_code, size},
    _disconnecting{disconnecting_code, size},
    _disconnected{disconnected_code, size},
    _snoozed{snoozed_code, size}
{

}

const IconResource &IconTheme::getIconForState(NativeTrayIconState::IconState state) const
{
    switch(state)
    {
        default:
        case NativeTray::IconState::Alert:
            return _alert;
        case NativeTray::IconState::Connected:
            return _connected;
        case NativeTray::IconState::Connecting:
            return _connecting;
        case NativeTray::IconState::Disconnected:
            return _disconnected;
        case NativeTray::IconState::Disconnecting:
            return _disconnecting;
        case NativeTray::IconState::Snoozed:
            return _snoozed;
    }
}
